<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Redis底层数据结构设计Redis是一个分布式缓存中间件，基于C语言写的key-value内存数据库，可以用于做数据缓存、分布式锁、海量数据统计、会话缓存、计数器、分布式队列、延迟队列、分布式ID生成等。Redis是一个键值对数据库，所以介绍Redis得从它的键值对说起，Redis的键只能为字符串对象，Redis的值有五种数据结构，分别是：string（字符串）、list（列表）、hash（字典">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis底层数据结构设计">
<meta property="og:url" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="个人成长博客">
<meta property="og:description" content="Redis底层数据结构设计Redis是一个分布式缓存中间件，基于C语言写的key-value内存数据库，可以用于做数据缓存、分布式锁、海量数据统计、会话缓存、计数器、分布式队列、延迟队列、分布式ID生成等。Redis是一个键值对数据库，所以介绍Redis得从它的键值对说起，Redis的键只能为字符串对象，Redis的值有五种数据结构，分别是：string（字符串）、list（列表）、hash（字典">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/string.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/emStr&raw.jpg">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/ziplist.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/quicklist.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/hash-ziplist.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset-ziplist.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/skiplist.png">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset1.jpg">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset2.jpg">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset3.jpg">
<meta property="og:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/redisDBstore.png">
<meta property="article:published_time" content="2020-08-22T08:27:51.000Z">
<meta property="article:modified_time" content="2020-09-05T14:05:52.434Z">
<meta property="article:author" content="EvenLjj">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/string.png">

<link rel="canonical" href="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis底层数据结构设计 | 个人成长博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">个人成长博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">纸上得来终觉浅，绝知此事要躬行</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EvenLjj">
      <meta itemprop="description" content="记录最近所学所思，让岁月留下汗水的痕迹">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人成长博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis底层数据结构设计
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-22 16:27:51" itemprop="dateCreated datePublished" datetime="2020-08-22T16:27:51+08:00">2020-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-05 22:05:52" itemprop="dateModified" datetime="2020-09-05T22:05:52+08:00">2020-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis底层数据结构设计"><a href="#Redis底层数据结构设计" class="headerlink" title="Redis底层数据结构设计"></a>Redis底层数据结构设计</h1><p>Redis是一个分布式缓存中间件，基于C语言写的key-value内存数据库，可以用于做数据缓存、分布式锁、海量数据统计、会话缓存、计数器、分布式队列、延迟队列、分布式ID生成等。Redis是一个键值对数据库，所以介绍Redis得从它的键值对说起，Redis的键只能为字符串<strong>对象</strong>，Redis的值有五种数据结构，分别是：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合）。</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>Redis的key和value都可以是字符串，并且上面也提到Redis是基于C语言开发，下面就来探究下Redis字符串是如何存储的。Redis没有直接使用C语言传统的字符串表示，而是自定义了一个字符串对象SDS（Simple Dynamic String），就是简单的动态字符串，作为Redis中字符串的默认存储。</p>
<p>Redis3.2之前SDS数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len; <span class="comment">//表示 buf（缓冲区）中已经使用的空间长度  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;<span class="comment">//表示 buf中未使用的长度  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];<span class="comment">//buf[] 表示缓冲区数组，存储字符         </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用SDS作为Redis默认字符串存储的好处：</p>
<table>
<thead>
<tr>
<th align="center">C语言字符串</th>
<th align="center">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">获取字符串长度的复杂度为O(N)</td>
<td align="center">获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td align="center">API是不安全的，可能会造成缓冲区溢出</td>
<td align="center">API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="center">修改字符串长度N次必然需要执行N次内存重分配</td>
<td align="center">修改字符串长度N次最多需要执行N次内存重分配</td>
</tr>
<tr>
<td align="center">只能保存文本数据</td>
<td align="center">可以保存文本数据或者二进制数据二进制安全</td>
</tr>
<tr>
<td align="center">可以使用所有C字符串函数库</td>
<td align="center">兼容部分C字符串函数库</td>
</tr>
</tbody></table>
<p>但是在<code>Redis 3.2 版本</code>中，对数据结构做出了修改，针对不同的长度范围定义了不同的结构的header，这样短字符串就能使用较小的存储结构，从而节省内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;      </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;5</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span>     <span class="comment">// 对应的字符串长度小于 1&lt;&lt;8</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span>                       <span class="comment">//目前字符创的长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;                                <span class="comment">//已经分配的总长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;                          <span class="comment">//flag用3bit来标明类型，类型后续解释，其余5bit目前没有使用</span></span><br><span class="line">    <span class="keyword">char</span> buf[];                                   <span class="comment">//柔性数组，以&#x27;\0&#x27;结尾</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;16</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;32</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span>    <span class="comment">// 对应的字符串长度小于 1&lt;&lt;64</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li>
<li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li>
<li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。</li>
<li>由sds字符指针先向低地址方向偏移1个字节的位置，得到flags字段，这样就可以得到具体header类型，获取了header类型，就能很快定位到它的len和alloc字段，如下图。</li>
<li>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32），如下图。</li>
</ul>
<img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/string.png" alt="SDS" style="zoom:50%;">

<h2 id="Redis对象"><a href="#Redis对象" class="headerlink" title="Redis对象"></a>Redis对象</h2><p>Redis使用对象来表示数据库中的键和值，每次我们在Redis数据库中创建一个键值对的时候，至少会创建两个对象，即键对象和值对象，对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;<span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 对象最后一次被访问的时间，当前时间减去该值就是对象的空转时长</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;<span class="comment">// 指向值对象的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>其中，type对应五种基本数据类型，encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，以下一个对象的类型以及对应的多种编码：</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>对象编码</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT、REDIS_ENCODING_EMBSTR、REDIS_ENCODING_RAW</td>
<td>整数（int）、embstr编码格式sds（embstr）、raw编码格式sds（raw）</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_LINKEDLIST</td>
<td>压缩列表（ziplist）、双端链表（linkedlist）</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET、REDIS_ENCODING_HT</td>
<td>整数集合（intset）、字典（hashtable）</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_SKIPLIST</td>
<td>压缩列表（ziplist）、跳跃表（skiplist）</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST、REDIS_ENCODING_HT</td>
<td>压缩列表（ziplist）、字典（hashtable）</td>
</tr>
</tbody></table>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>首先说下REDIS_STRING，字符串对象保存的数据是整型与字符串。字符串对象的底层有着三种实现结构：整数、embstr编码的sds字符串、raw编码的sds字符串。</p>
<p>当字符串对象保存的是一个整型值，那么字符串对象会将整数值保存在字符串对象的ptr属性中。当存入的是一个不大于44字节的字符串时，就采用embstr编码的sds字符串保存数据，而大于44字节的字符串就采用raw编码的字符串来保存。raw编码的ads与embstr编码的sds主要的区别在于embstr编码的sds内存与redisObj内存是在一块的(因为一起分配的内存)，所以保存的字符串是在其整体里，字符数据与对象共存亡。如下图所示：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/emStr&raw.jpg"></p>
<p><strong>编码的转换</strong>，int编码的字符串对象和emstr编码的字符串对象满足的情况下，会被转换为raw编码的字符串对象。对于int编码的字符串对象来说，执行命令让其不再是字符串对象时，字符串编码将从int变为raw。Redis对于embstr编码的对象没有修改程序，所以embstr字符串其实是只读的。当我们对于embstr编码的字符串对象进行修改命令时，程序先将对象编码从embstr转换为raw然后执行修改操作。所以，当对于一个embstr编码的字符串对象执行修改命令后，总会变成一个raw编码的字符串对象。</p>
<p><strong>字符串扩容</strong>，需要注意的是当字符长度小于1MB时，扩容都是加倍现有的空间。如果字符串长度超过1MB，扩容时一次只会多扩1MB的空间，字符串最大长度为512MB。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>linkedlist，类似于java当中的LinkedList，普通的双向链表结构。</p>
<p>ziplist，Redis为了节约内存空间使用，很多数据结构都使用到了压缩列表来存储。压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。entry随容纳的元素类型不同，也会有不同的结构。prevlen表示前一个entry的长度，当压缩列表倒着遍历的时候，需要通过这个字段来快速定位到下一个元素位置。Redis为了节约存储空间，根据len前缀来识别具体存储的数据形式。如下图所示：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/ziplist.png"></p>
<p>Redis早期存储少量元素时使用ziplist，当元素多的时候用linkedlist。考虑到链表的附加空间相对太高，prev和next指针就要占据16个字节（64位操作系统为8个字节），每个链表节点的内存都单独分配，会加剧内存碎片化，影响内存管理效率。Redis的新的版本对列表数据结构进行了改造，使用quicklist代替了ziplist和linkedlist。quicklist是ziplist和linkedlist的混合体，它将linkedlist按段切分，每一段使用ziplist让存储紧凑，多个ziplist之间使用双向指针串连起来，如下图：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/quicklist.png"></p>
<p>quicklist内部默认单个ziplist长度为8KB，超出了这个字节数，会另起一个ziplist，可以通过list-max-ziplist-size配置。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典在Redis中应用比较广泛，哈希键以及Redis数据库都是基于字典实现。Redis中的字典相当于Java中的HashMap，采用的是数组加链表的哈希表结构来存储。当需要新增一个键值对时，首先根据键值计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上。当发生哈希冲突时，Redis使用头插法将碰撞的元素使用链表串起来。</p>
<p>哈希表代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>其中，table属性是一个数组，数组中每个元素指向dictEntry结构的指针，即哈希表节点，每个哈希表节点保存着一个键值对。size属性记录了哈希表的大小，即table的大小，而used则记录了哈希表已有键值对的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键放到table的哪个索引上。</p>
<p>哈希表节点代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>其中key保存着键值对的键，v保存着键值对的值，其中值可以为一个指针，或者uint64_t整数，或者int64_t的整数，double浮点数。next指针指向另一个哈希表节点，用来解决哈希冲突。</p>
<p>字典的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type; <span class="comment">//类型特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">//哈希表</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>其中type和privdate属性是针对不同类型的键值对，为创建字典多态设置的。ht属性是一个包含两个项的数组，数组中每一项都是一个dictht的哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表rehash用。rehashidx则记录了rehash的进度，没有rehash是为-1。</p>
<p>Redis的字段和Java的hashMap的不同，Redis的字典的值只能是字符串，并且他们rehash的方式不一样。Java中的rehash是一次性完成的，所以当字典很大的时候，耗时比较久。Redis为了追求高性能，不饿能阻塞服务，采用的是渐进式rehash策略。</p>
<p>Redis渐进式rehash的步骤如下：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash正式开始。</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，完成rehashidx加一。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash到ht[1]，这时程序将rehashidx属性设置为-1，表示rehash操作完成。</li>
</ol>
<p>另外当一个哈希键只包含少量键对，并且每个键值对的键和值要么是小整数值，要么是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现，如图两个键值对，通过压缩列表作为底层存储：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/hash-ziplist.png"></p>
<p><strong>编码的转换</strong>，当哈希对象满足以下两个条件时，哈希对象以ziplist编码，否则以hashtable编码：</p>
<ol>
<li>哈希对象保存的所有键值对的字符串长度都小于64字节。</li>
<li>哈希对象保存的键值对数量小于512个。</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Redis的集合相当于Java中的HashSet，它内部的键值对是无序的、唯一的。集合对象的编码可以是intset和hashtable。</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，并代表了一个集合元素，字典的值全部置为NULL。</p>
<p><strong>编码转换</strong>，当集合对象满足以下两个条件时，对象使用intset编码，否则使用hashtable编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值。</li>
<li>集合对象保存的元素数量不超过512个。</li>
</ol>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合顾名思义，就是有顺序的集合，主要通过给每个集合元素设置一个score来实现有序，有序集合的编码可以是ziplist和skiplist。</p>
<p>使用压缩列表作为底层实现时，每个集合元素使用两个紧挨在一起的压缩列表节点来保存。第一个节点保存元素的值（member），第二个元素保存元素的分数（score），如图，有序集合元素在压缩列表中按分值从小到大排列：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset-ziplist.png"></p>
<p>跳跃表实现的有序集合代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>跳跃表节点，其中ele为数据值，score为数据对应的分数，backward指向前一个节点的指针（前向指针），level[]，数组的大小为层数，存放的是各层链表后一个节点的指针，其中每层forward表示单层的后向指针，span表示当前指针到后面元素跨越了多少个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳跃表，header和tail分别指向跳跃表的表头和表尾节点，通过该指针，程序定位表头节点和表尾节点的时间复杂度为o(1),length属性来记录节点的数量，level属性用来记录跳跃表中层高最大的那个几点的层数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>以skiplist编码的有序集合对象zset，一个zset包含了一个字典和一个跳跃表，zsl跳跃表按分值从小到大保存了所有集合对象。dict字典为有序集合创建了一个从成员到分值的映射。字典的键保存了一个集合元素，值则是相应的分值。</p>
<p>使用跳跃列表作为底层实现有序列表结构示意图如下：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/skiplist.png"></p>
<p>其中有三个元素，a为一层，b三层，c两层。</p>
<p>上面的图还不够直观，下面就举个直观的例子，来讲解跳跃列表，</p>
<p>有一个有序表如下，从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset1.jpg"></p>
<p>有没有优化的算法吗?  链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了得到如下结构：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset2.jpg"></p>
<p>还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/zset3.jpg"></p>
<p>总结了跳跃列表的一些特性：</p>
<ol>
<li>新插入一个元素不会影响其它元素的层数</li>
<li>每一层都是一个有序的链表</li>
<li>最底层(Level 1)的链表包含所有元素</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素</li>
<li>跳跃列表共有64层，能容纳2的64次方个与元素</li>
<li>跳跃列表对于每一个新插入的节点，都需要调用一个随机算法给它分配一个合理的层数。其中期望是50%分配到level1，25%的概率被分配到leve2，12.5%的概率分配到level3，以此类推，2的负63次方的概率分配到最顶层</li>
<li>插入元素时，搜索合适插入点的过程中将搜索路径找出来，然后为这个新节点随机分配一个层数，再将搜索路径上的节点和这个新节点通过前向后向指针串起来。如果分配的新节点的高度高于当前跳跃列表的最大高度，就需要更新一下跳跃列表的最大高度</li>
<li>删除过程和插入过程类似，需要先把这个搜索路径找出来，然后对于每个层的相关节点更新一下前向后向指针，同时还要注意更新下最高层数</li>
<li>更新，如果value不存在则为新增，如果存在只是改动score的值，则为更新。Redis的策略是先删除该元素，然后新增</li>
<li>score一样时，redis还会根据比较value的值</li>
<li>元素的排名rank值是根据搜索路径上所有span值的叠加计算出来的，Redis在插入、删除操作时都需要更新span的值</li>
</ol>
<h2 id="Redis主体对象结构"><a href="#Redis主体对象结构" class="headerlink" title="Redis主体对象结构"></a>Redis主体对象结构</h2><p>最后来总结下RedisDB主体数据结构：</p>
<p><img src="/2020/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/redisDBstore.png" alt="redisDBstore"></p>
<p>Redis的整体结构图如上图所示，首先RedisDb中包含了Redis整体的信息，redisDb.id 存储着 redis 数据库以整数表示的号码。redisDb.expires 保存着每一个键的过期时间，redisDb.dict 存储着该库所有的键值对数据。当redis 服务器初始化时，会预先分配 16 个数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。</p>
<p>由上述的结构可以看出，redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而1号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以redis 中查找一个key，其实就是对进行该dict 结构中的 ht[0] 进行查找操作。最终哈希表节点上保存了key和val，val指向了实际的redis对象，redis对象则根据实际的type和encoding保存具体数据结构的值。</p>
<p>既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据key的哈希值找到该列表后，如果列表的长度大于1，那么我们需要遍历该链表来找到我们所查找的key。</p>
<p>了解了上述知识之后，我们就可以来分析redis如果在内存找到一个key了：</p>
<ol>
<li>当拿到一个key后， redis 先判断当前库的0号哈希表是否为空，即：if (dict-&gt;ht[0].size == 0)。如果为true直接返回NULL。</li>
<li>判断该0号哈希表是否需要rehash，因为如果在进行rehash，那么两个表中者有可能存储该key。如果正在进行rehash，将调用一次_dictRehashStep方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash。</li>
<li>计算哈希表，根据当前字典与key进行哈希值的计算。</li>
<li>根据哈希值与当前字典计算哈希表的索引值。</li>
<li>根据索引值在哈希表中取出链表，遍历该链表找到key的位置。一般情况，该链表长度为1。</li>
<li>当 ht[0] 查找完了之后，再进行了次rehash判断，如果未在rehashing，则直接结束，否则对ht[1]重复345步骤。<br>到此我们就找到了key在内存中的位置了。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/22/beginning/" rel="prev" title="写在最初">
      <i class="fa fa-chevron-left"></i> 写在最初
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/07/jvm/" rel="next" title="Java虚拟机综述">
      Java虚拟机综述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">Redis底层数据结构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS"><span class="nav-number">1.1.</span> <span class="nav-text">SDS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.</span> <span class="nav-text">Redis对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">1.5.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.6.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="nav-number">1.7.</span> <span class="nav-text">有序集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BD%93%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.8.</span> <span class="nav-text">Redis主体对象结构</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">EvenLjj</p>
  <div class="site-description" itemprop="description">记录最近所学所思，让岁月留下汗水的痕迹</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EvenLjj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
